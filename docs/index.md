# Введение

Библиотека для решения уравнений методом Нелдера - Мида.

## Ключевые возможности
1. Парсинг инфиксной записи уравнения в дерево выражения.
2. Вычисление значения выражения с определённым вектором переменных.
3. Поиск симплекса, в окрестностях которого существует локальный минимум выражения.

## Классы
- Point.
    - Класс, представляющий точку в N-мерном пространстве.
    - Хранит координаты точки в виде вектора чисел с плавающей запятой. 
    - Предоставляет методы для создания, доступа, модификации и клонирования точек.
- Simplex.
    - Класс, представляющий симплекс в N-мерном пространстве
    - Класс управляет набором точек (вершин).
    - предоставляет операции для работы с симплексом.
- SimplexHistory.
    - Класс для хранения истории изменений симплекса в процессе оптимизации
    - Предоставляет функционал для сохранения состояний симплекса на разных итерациях алгоритма и последующего получения истории изменений в виде структурированных данных.
    - Представляет методы для представления истории.
- ExpressionTree.
    - Класс для представления и вычисления выражений. Наследуется от интерфейса IFunction.
    - Содержит ссылку на корневой узел типа TreeNode.
    - Содержит методы для работы с выражением.
- NelderMeadMethod.
    - Класс для поиска локального минимума.
    - Содержит ссылку объект выражения IFunction и коэффициенты.
    - Содержит методы для работы с алгоритмом.

Подробная документация представлена в коде и собирается в html документ с помощью Doxygen.

# Использование 
1. Экспортируйте библиотеку в проект.
2. Используйте функцию ExpressionTree::create_tree(string), что бы создать дерево выражения. Передоваемая строка должна включать корректное инфиксное выражение с переменными. Переменные записываются в формате "xi". i принимает значения от 1.
3. Результат выражения возвращает функция ExpressionTree::evaluate_tree(...). Для этого создайте объект Point и передайте его ссылку в evaluate_tree. 
4. В случае возникноения ошибок будет выбрасывается исключение std::invalid_argument с сообщение ошибки.
5. Создайте объет алгоритма Нелдера-Мида NelderMeadMethod(tree)
6. Найдите локальный минимум с NelderMeadMethod::minimum_search(). minimum_search вернёт ссылку на объект SimplexHistory. 

# Пример на С++ 
```
  ExpressionTree* tree = ExpressionTree::create_tree("x1^2+x2^2");
  std::cout << tree->json_tree();
  std::vector<double> p = {1, 4};
  IPoint* point = new Point(p);
  std::cout << "\nRes: " << tree->evaluate(point) << "\n";

  std::vector<IPoint*> simplex;
  for (int i = 0; i < 3; i++) {
    std::vector<double> g = {1.0 + i, 2.0 - i * i};
    IPoint* new_point = new Point(g);
    simplex.push_back(new_point);
  }

  Simplex* sim = Simplex::create_simplex(simplex);

  NelderMeadMethod nel = NelderMeadMethod(tree, 1.0, 2.0, 0.5, 0.5, 1.0E-10);
  nel.set_simplex(sim);

  SimplexHistory* histor = nel.minimum_search();
  vector<Simplex*> his = histor->get_vector_history();

  int dem = sim->get_vertex(0)->dimensions();
  for (auto sim : his) {
    for (int i = 0; i < dem + 1; i++) {
      for (int j = 0; j < dem; j++) {
        std::cout << sim->get_vertex(i)->get(j) << " ";
      }
      std::cout << " || ";
    }
    std::cout << "\n";
  }

  delete histor;
  delete point;
  delete sim;
  delete tree;

  return 0;
``` 
